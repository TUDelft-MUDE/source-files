on:
  push:
    branches:
      - '**'

permissions:
  contents: write

jobs:
  detect-and-update:
    name: Detect binary files and update .gitattributes
    runs-on: ubuntu-latest
    steps:
      - name: Exit when run by GitHub Actions bot
        if: ${{ github.actor == 'github-actions[bot]' }}
        run: |
          echo "Triggered by github-actions[bot] â€” exiting to avoid a loop."
      - name: Checkout repository
        if: ${{ github.actor != 'github-actions[bot]' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Configure git user
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      - name: Detect binary files under file/ and build new .gitattributes
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          set -euo pipefail
          REPO_ROOT="$(pwd)"
          EXISTING="${REPO_ROOT}/.gitattributes"
          TMP_BASE="$(mktemp)"
          TMP_NEW="$(mktemp)"
          # Preserve existing .gitattributes but remove any lines that start with file/
          if [ -f "${EXISTING}" ]; then
            grep -vE '^[[:space:]]*file\/' "${EXISTING}" > "${TMP_BASE}" || true
          else
            touch "${TMP_BASE}"
          fi
          # List tracked files under "file/" (including files directly in file/)
          # and emit per-file LFS lines for non-text files.
          # Use a NUL-separated loop to safely handle all filenames.
          git ls-files -z -- file || true
          : > "${TMP_NEW}"
          git ls-files -z -- file | while IFS= read -r -d '' f; do
            if [ -f "$f" ]; then
              mime=$(file --mime -b "$f" 2>/dev/null || echo "")
              # Treat as binary if mime does not start with text/ and is not empty
              if ! printf "%s" "$mime" | grep -qE "^text/|^inode/x-empty"; then
                printf "%s filter=lfs diff=lfs merge=lfs -text\n" "$f"
              fi
            fi
          done >> "${TMP_NEW}" || true
          # Merge preserved base + new binary entries
          cat "${TMP_BASE}" > "${REPO_ROOT}/.gitattributes.new"
          if [ -s "${TMP_NEW}" ]; then
            echo "" >> "${REPO_ROOT}/.gitattributes.new"
            cat "${TMP_NEW}" >> "${REPO_ROOT}/.gitattributes.new"
          fi
          # Remove duplicate lines while preserving first occurrence
          awk '!seen[$0]++' "${REPO_ROOT}/.gitattributes.new" > "${REPO_ROOT}/.gitattributes.final"
          mv "${REPO_ROOT}/.gitattributes.final" "${REPO_ROOT}/.gitattributes"
          echo "Computed .gitattributes (preview):"
          git --no-pager diff -- .gitattributes || true
      - name: Commit and push updated .gitattributes if changed
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          if git status --porcelain -- .gitattributes | grep -q .; then
            git add .gitattributes
            git commit -m "chore: update .gitattributes for binary files under file/ (automated)"
            git push
          else
            echo "No .gitattributes changes to commit."
          fi