on:
  push:
    branches:
      - '**'

permissions:
  contents: write

jobs:
  detect-and-update:
    name: Detect binary files and update .gitattributes
    runs-on: ubuntu-latest
    steps:
      # If this run was triggered by the bot itself, skip the rest to avoid loops.
      - name: Exit when run by GitHub Actions bot
        if: ${{ github.actor == 'github-actions[bot]' }}
        run: |
          echo "Triggered by github-actions[bot] â€” exiting to avoid a loop."
      - name: Checkout repository
        if: ${{ github.actor != 'github-actions[bot]' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Configure git user
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      - name: Detect binary files under file/ and build new .gitattributes
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          set -euo pipefail
          REPO_ROOT="$(pwd)"
          EXISTING="${REPO_ROOT}/.gitattributes"
          TMP_BASE="$(mktemp)"
          TMP_NEW="$(mktemp)"
          # Preserve existing .gitattributes but remove any lines that start with file/
          if [ -f "${EXISTING}" ]; then
            # remove lines that begin with "file/" (allow leading whitespace)
            grep -vE '^[[:space:]]*file\/' "${EXISTING}" > "${TMP_BASE}" || true
          else
            touch "${TMP_BASE}"
          fi
          # Find tracked files under file/ and emit per-file LFS lines for non-text files
          # If no tracked files under file/ exist, git ls-files -z will exit non-zero; handle gracefully
          git ls-files -z file || true
          git ls-files -z file | xargs -0 -r -I{} sh -c '
            if [ -f "{}" ]; then
              mime=$(file --mime -b "{}" 2>/dev/null || echo "")
              # Treat as binary if mime does not start with text/ and is not empty
              if ! printf "%s" "$mime" | grep -qE "^text/|^inode/x-empty"; then
                printf "%s filter=lfs diff=lfs merge=lfs -text\n" "{}"
              fi
            fi
          ' > "${TMP_NEW}" || true
          # Merge preserved base + new binary entries
          cat "${TMP_BASE}" > "${REPO_ROOT}/.gitattributes.new"
          if [ -s "${TMP_NEW}" ]; then
            echo "" >> "${REPO_ROOT}/.gitattributes.new"
            cat "${TMP_NEW}" >> "${REPO_ROOT}/.gitattributes.new"
          fi
          # Remove duplicate lines while preserving first occurrence
          awk '!seen[$0]++' "${REPO_ROOT}/.gitattributes.new" > "${REPO_ROOT}/.gitattributes.final"
          mv "${REPO_ROOT}/.gitattributes.final" "${REPO_ROOT}/.gitattributes"
          # Show diff for debugging; exit-code ignored so workflow continues
          echo "Computed .gitattributes (preview):"
          git --no-pager diff -- .gitattributes || true
      - name: Commit and push updated .gitattributes if changed
        if: ${{ github.actor != 'github-actions[bot]' }}
        run: |
          if git status --porcelain -- .gitattributes | grep -q .; then
            git add .gitattributes
            git commit -m "chore: update .gitattributes for binary files under file/ (automated)"
            git push
          else
            echo "No .gitattributes changes to commit."
          fi